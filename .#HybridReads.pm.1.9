###
# Pod Documentation
###

=head1 NAME

HybridReads.pm

=head1 SYNOPSIS

Module for making predictions from hybrid reads.

=head1 DESCRIPTION

=head1 AUTHOR

Jeffrey Barrick
<jbarrick@msu.edu>

=head1 COPYRIGHT

Copyright 2008.  All rights reserved.

=cut

###
# End Pod Documentation
###

package HybridReads;
use strict;

require Exporter;
our @ISA = qw( Exporter );
our @EXPORT = qw( hybrid_read_predictions );

use MummerDelta;
use BreseqUtility;
use AlignmentMaker;
use FastqLite;

use Data::Dumper;

### constants
my $junction_sequence_flanking_length = 100;
my $new_junction_sequence_tag = "NEW-JUNCTION:::";

sub hybrid_read_predictions
{
	my $debug = 0;
	my ($reference_sequence_string_hash_ref, $gene_list_hash_ref, $is_list_hash_ref, $seq_id,
		$hybrid_read_path, $hybrid_read_fasta_file_name, $hybrid_read_delta_file_name, 
		$truncated_read_fasta_file_name, $truncated_read_delta_file_name, $junction_file_name,
		$candidate_junctions_file_name, $hybrid_read_mummer_prefix, $truncated_read_mummer_prefix,
		$hybrid_read_fastq_file_name, $truncated_read_fastq_file_name
		) = @_;

	print STDERR "Analyzing hybrid reads...\n";

	if (-e "$candidate_junctions_file_name")
	{
		print STDERR "  Candidate junction file already created.\n";
	}
	else
	{
		## create FASTA file of possible junctions from these groups
		print STDERR "  Creating candidate junction file...\n";
		print_candidate_junctions($hybrid_read_delta_file_name, $hybrid_read_fastq_file_name, $candidate_junctions_file_name, $reference_sequence_string_hash_ref, $seq_id, $junction_sequence_flanking_length);

	}
	
	## use MUMmer to re-check against new junctions
	
	##minimum size of exact match...
	my $minmatch = 14;

	##minimum size of match to be extended...
	my $mincluster = $minmatch;

	#breaklength is how far we force extension to the end of the read
	#it is only used if --nooptimize is enabled
	my $breaklen = 0;
	
	if (-s "$candidate_junctions_file_name" == 0)
	{
		print STDERR "  No new junction candidates found.\n";
		return [];
	}
	
	if (!-e "$hybrid_read_mummer_prefix.delta") {
		print STDERR "  Testing for hybrid matches to candidate junctions...\n";
		my $command = "nucmer --maxmatch -c $mincluster  -l $minmatch --prefix $hybrid_read_mummer_prefix $candidate_junctions_file_name $hybrid_read_fasta_file_name";	 ## -b $breaklen --nooptimize
		print STDERR "$command\n";
		my $res = system $command;
		die "$res" if ($res);
		unlink "$hybrid_read_mummer_prefix.cluster";
	}
	else
	{
		print STDERR "  Hybrid read matching to candidate junctions already complete.\n";
	}
	
	if (!-e "$truncated_read_mummer_prefix.delta") {
		print STDERR "  Testing for truncated matches to candidate junctions...\n";
		my $command = "nucmer --maxmatch -c $mincluster  -l $minmatch --prefix $truncated_read_mummer_prefix $candidate_junctions_file_name $truncated_read_fasta_file_name";	 ## -b $breaklen --nooptimize
		print STDERR "$command\n";
		my $res = system $command;
		die "$res" if ($res);
		unlink "$truncated_read_mummer_prefix.cluster";
	}
	else
	{
		print STDERR "  Truncated read matching to candidate junctions already complete.\n";
	}
			
	## Load OLD and NEW delta files at the same time, filter out redundant hits, ignore multiple match groups
	
	print STDERR "  Determining best junctions...\n";

	
	my $hybrid_read_delta = MummerDelta->new(-file_name => "$hybrid_read_delta_file_name");
	my $candidate_delta = MummerDelta->new(-file_name => "$hybrid_read_mummer_prefix.delta");
	
	## We only care about matches to candidates
	## but we also need to load their other matches to be sure that these are better.
	## They are in the same order and we KNOW that they have a match in
	## the hybrid delta file, so we can traverse the lists efficiently
	## one read at a time
	
	my %matched_junction;
	my %need_sequences;

	## go through each group and look at the best matches
	## count up how many reads go with each junction candidate (ties are redistributed they share an end and one is clear winner), 
	## save their sequences to make an alignment to show.	
	
	my @candidate_list = $candidate_delta->get_next_list;
	
	while (scalar @candidate_list > 0)
	{	
		#print STDERR Dumper(@candidate_list);
		#print STDERR "$candidate_list[0]->{query}\n";
		die if (!defined $candidate_list[0]->{query});
		my @hybrid_list;
		do {
			@hybrid_list = $hybrid_read_delta->get_next_list;
			#print STDERR " $hybrid_list[0]->{query}\n";
		} while ((scalar @hybrid_list > 0) && ($hybrid_list[0]->{query} ne $candidate_list[0]->{query}));
	
		push @candidate_list, @hybrid_list;	
		
		print STDERR "candidate matches\n" if ($debug);	
		print STDERR Dumper(@candidate_list) if ($debug);
			
		my @best_match_list = MummerDelta::remove_dominated_matches_from_list(@candidate_list);
		#print STDERR Dumper(@best_match_list);
		
		
		print STDERR "best matches\n" if ($debug);	
		print STDERR Dumper(@best_match_list) if ($debug);
		
		## there may be ties where the sequence equally well matches two places
		## in this case it most likely matches the junction that has *less* overlap
		foreach my $match (@best_match_list)
		{
			$match->{junction_overlap} = -9999;
			if ($match->{reference} =~ m/^$new_junction_sequence_tag/)
			{
				my @list = split /_|\//, $match->{reference};
				$match->{junction_overlap} = $list[7];
			}
		}
			
		@best_match_list = sort { $a->{junction_overlap} <=> $b->{junction_overlap} } @best_match_list;
		
		##remove me
		print STDERR "sorted matches\n" if ($debug);	
		print STDERR Dumper(@best_match_list) if ($debug);

		## We only keep if the best nondominated match to this read is not to the reference genome...
		my $best_match = $best_match_list[0];
		if ($best_match->{junction_overlap} != -9999)
		{
			## ...AND it is to one of our candidates, not to a genomic fragment...
			if ($best_match->{reference} =~ m/^$new_junction_sequence_tag/)
			{
				#print "Valid $best_match->{reference}\n";
								
				## ...AND it overlaps the actual junction in the read!
				my $match = 0;
				if ($best_match->{junction_overlap} > 0) ##junction had shared sequence between reads on the two sides
				{
					#must match the flanking length and glanking length minus overlap
					$match = 1 if ( ($junction_sequence_flanking_length - $best_match->{junction_overlap} >= $best_match->{reference_start}) && ($junction_sequence_flanking_length <= $best_match->{reference_end}) );
				} 
				else ##junction had novel sequence
				{
					$match = 1 if ( ($junction_sequence_flanking_length >= $best_match->{reference_start}) && ($best_match->{reference_length}-$junction_sequence_flanking_length <= $best_match->{reference_end}) );
				}
								
				if ($match)
				{				
					push @{$matched_junction{$best_match->{reference}}}, $best_match; 
					$need_sequences{$best_match->{query}} = $best_match;
				}
			}
		}
		@candidate_list = $candidate_delta->get_next_list;
	}
	
	print STDERR "  Adding predicted junction reference sequences for alignments...\n";
	my $junction_refseqs;
	my $junction_ref_seq_fasta = Bio::SeqIO->new( -file => "$candidate_junctions_file_name", -format => "fasta", -verbose => -1);
	while (my $junction_ref_seq = $junction_ref_seq_fasta->next_seq)
	{
		next if (!defined $matched_junction{$junction_ref_seq->id});
		$junction_refseqs->{$junction_ref_seq->id} =  $junction_ref_seq->seq;
	}
	
	my %match_junction_info;
	foreach my $key (keys %matched_junction)
	{
		my $new_item;		
		$new_item->{num_complete_matches} = 0;
		foreach my $match (@{$matched_junction{$key}})
		{
			if (($match->{query_start} == 1) && ($match->{query_end} == $match->{query_length}))
			{
				$new_item->{num_complete_matches}++;
			}
		}
		
		$match_junction_info{$key} = $new_item;
	}


	## ok, we do the alignment maker steps of loading reads here by ourselves since the data is handy
	## and this avoids spurious matches that would be present if we cycle through the raw data again!
	#AlignmentMaker::add_aligned_reads_to_intervals(\@hybrid_list, $hybrid_read_fastq_file_name, "$hybrid_read_mummer_prefix.delta");	
	
	my $in = FastqLite->new( -file => "<$hybrid_read_fastq_file_name");
	while (my $seq = $in->next_seq)
	{
		my $m = $need_sequences{$seq->{id}};
		if ($m)
		{
			$m->{read_fastq} = $seq;
		}
	}
	
	
	#print STDERR "  Printing predicted new junctions...\n";
	
	## print out results (and save for later html output)	
	
	my @hybrid_list;
	## sort by complete matches
	my @sorted_keys = sort { -($match_junction_info{$a}->{num_complete_matches} <=> $match_junction_info{$b}->{num_complete_matches}) } keys %match_junction_info;
	@sorted_keys = grep { $match_junction_info{$_}->{num_complete_matches} > 3 } @sorted_keys;
	
	my $g = 0;
	foreach my $key (@sorted_keys)
	{
		## temporary text output
		my @split_key = split /\/|_/, $key;
		my $upstream_reference = $split_key[1];
		my $upstream_position = $split_key[2];
		my $upstream_direction = $split_key[3];
		my $downstream_reference = $split_key[4];
		my $downstream_position = $split_key[5];
		my $downstream_direction = $split_key[6];
		my $overlap = $split_key[7];
		
		## create an interval for making alignments and html output
		my $item;
		
		## the overall start and end apply to the made up junction!!!
		$item->{start} = $junction_sequence_flanking_length;
		$item->{end} = $junction_sequence_flanking_length + $overlap-1;
		$item->{reference} = $key;
		$item->{ref_seq_ref} = \$junction_refseqs->{$key};
		@{$item->{aligned_reads}} = @{$matched_junction{$key}};
		
		my $alignment_reference_info_1 = { 
			truncate_end => $junction_sequence_flanking_length, 
			ghost_end => $upstream_position, 
			ghost_strand => $upstream_direction,
			ghost_reference => $upstream_reference
		};
	
		my $alignment_reference_info_2 = { 
			truncate_start => $junction_sequence_flanking_length+1-$overlap, 
			ghost_start => $downstream_position, 
			ghost_strand => $downstream_direction,
			ghost_reference => $downstream_reference
		};
		push @{$item->{alignment_reference_info_list}}, $alignment_reference_info_1, $alignment_reference_info_2;
		$item->{alignment_empty_change_line} = 1;
			
				
		#### NOTE: For these intervals, the strand indicates which direction (relative to top strand of genome)
		####       you move until you hit the given position to reproduce sequence in new junction.		
		$item->{interval_1}->{start} = $upstream_position;
		$item->{interval_1}->{end} = $upstream_position;
		$item->{interval_1}->{strand} = $upstream_direction;		
		$item->{interval_1}->{reference} = $upstream_reference;

		$item->{interval_2}->{start} = $downstream_position;
		$item->{interval_2}->{end} = $downstream_position;
		$item->{interval_2}->{strand} = $downstream_direction; #switch strand so it refers to direction from position to seq in junction
		$item->{interval_2}->{reference} = $downstream_reference;
	
		$item->{total_reads} = scalar @{$matched_junction{$key}};
		$item->{full_length_reads} = $match_junction_info{$key}->{num_complete_matches};
		$item->{overlap} = $overlap;
		
		#print STDERR Dumper($item);
		
		#add gene information for each end
		$item->{hybrid} = $item;
		foreach my $key ('interval_1', 'interval_2')
		{
			##create circular reference to self so we can print table at the top of the alignment
			$item->{$key}->{hybrid} = $item;
		
			my ($prev_gene, $gene, $next_gene) = find_nearby_genes($item->{$key}, $gene_list_hash_ref->{$seq_id});		

			## noncoding
			if (!$gene)
			{
				$item->{$key}->{gene}->{gene} .= ($prev_gene && $prev_gene->{gene}) ? $prev_gene->{gene} : '-';
				$item->{$key}->{gene}->{gene} .= "/";
				$item->{$key}->{gene}->{gene} .= ($next_gene && $next_gene->{gene}) ? $next_gene->{gene} : '-';
		
				if (defined $prev_gene)
				{
					$item->{$key}->{gene}->{position} .= ($prev_gene->{strand} == +1) ? "+" : "-";
					$item->{$key}->{gene}->{position} .= ($item->{$key}->{start} - $prev_gene->{end});
				}
				$item->{$key}->{gene}->{gene_position} .= "/";
				if (defined $next_gene)
				{
					$item->{$key}->{gene}->{position} .= ($next_gene->{strand} == +1) ? "-" : "+";
					$item->{$key}->{gene}->{position} .= ($next_gene->{start} - $item->{$key}->{end});
				}
				
				$item->{$key}->{gene}->{product} .= ($prev_gene && $prev_gene->{product}) ? $prev_gene->{product} : '-';
				$item->{$key}->{gene}->{product} .= "/";			
				$item->{$key}->{gene}->{product} .= ($next_gene && $next_gene->{product}) ? $next_gene->{product} : '-';

				$item->{$key}->{gene}->{interval} .= $prev_gene->{end}+1 if $prev_gene;
				$item->{$key}->{gene}->{interval} .= "/"; 
				$item->{$key}->{gene}->{interval} .= $next_gene->{start}-1 if $next_gene; 

			} 
			
			## coding
			else
			{
				$item->{$key}->{gene}->{gene} = $gene->{gene};
				$item->{$key}->{gene}->{product} = $gene->{product};
				my $gene_start = ($gene->{strand} == +1) ? $gene->{start} : $gene->{end};	
				$item->{$key}->{gene}->{position} = abs($item->{$key}->{start}-$gene_start) + 1;
				$item->{$key}->{gene}->{interval} = ($gene->{strand} == +1) ? "$gene->{start}-$gene->{end}" : "$gene->{end}-$gene->{start}"; 
 
			}
			
			
			## determine IS elements
			## Is it within an IS or near the boundary of an IS in the direction leading up to the junction?			
			if (my $is = find_closest_is_element($item->{$key}, $is_list_hash_ref->{$seq_id}, 200, $item->{$key}->{strand}))
			{
				$item->{$key}->{is}->{gene} = $is->{gene};
				
				
				$item->{$key}->{is}->{interval} = ($is->{strand} == +1) ? "$is->{start}-$is->{end}" : "$is->{end}-$is->{start}"; 
				$item->{$key}->{is}->{product} = $is->{product};
			}
			$item->{$key}->{annotate_key} = (defined $item->{$key}->{is}) ? 'is' : 'gene';

			
		}
		#print STDERR Dumper($item);

		push @hybrid_list, $item;
		
	}
	return @hybrid_list;
}


=head2 read_to_match_info

 Title   : read_to_match_info
 Usage   : read_to_match_info( $read, $ref_string );
 Function: divides matches in a read into groups
 Returns : 
 
=cut

sub read_to_match_info
{
	my ($read_list_ref, $ref_string, $read_seq) = @_;
	
	my $match_info;
	$match_info->{read_seq}->{1} = $read_seq->{seq};
	my $temp_seq = Bio::Seq->new('-seq' => $read_seq->{seq});
	$match_info->{read_seq}->{-1} = $temp_seq->revcom->seq;
		
	@{$match_info->{groups}} = MummerDelta::to_match_groups(@$read_list_ref);
	foreach my $mg (@{$match_info->{groups}})
	{
		add_matched_ref_seq_to_match_groups($mg, $ref_string);
	}
		
	return $match_info;
}

sub add_matched_ref_seq_to_match_groups
{
	my ($mg, $ref_string) = @_;
	
	my $m = $mg->{matches}->[0];
	$mg->{ref_seq_matched}->{$m->{strand}} = substr $ref_string, $m->{reference_start}-1, $m->{reference_end}-$m->{reference_start}+1;	
	my $tmp_seq = Bio::Seq->new(-seq => $mg->{ref_seq_matched}->{$m->{strand}});
	$mg->{ref_seq_matched}->{-$m->{strand}} = $tmp_seq->revcom()->seq;	
}

=head2 correct_overlapping_mismatches

 Title   : correct_overlapping_mismatches
 Usage   : correct_overlapping_mismatches( $mi );
 Function: divides matches in a read into groups
 Returns : 
 
=cut

sub correct_overlapping_mismatches
{
	my $debug = 0;
	my ($mi, $ref_string) = @_;
	
	my $unique_hit = $mi->{groups}->[0]->{matches}->[0];
	my $second_hit = $mi->{groups}->[1]->{matches}->[0];

	return if ($unique_hit->{mismatches} == 0) && ($second_hit->{mismatches} == 0);
	
	#print STDERR "Needs adjustment...\n";
	#print STDERR Dumper($mi);
	
	#first write, does not check for indels
	#check the region in the second hit overlapping the first
	
	foreach my $hit ($second_hit, $unique_hit)
	{
		next if ($hit->{mismatches} == 0);
	
		my $other_hit = ($hit == $unique_hit) ? $second_hit : $unique_hit;
		my $mg = ($hit == $unique_hit) ? $mi->{groups}->[0] : $mi->{groups}->[1];
		
		my $overlap_start = ($other_hit->{read_side} == -1) ? $hit->{query_start} : $other_hit->{query_start};
		my $overlap_end = ($other_hit->{read_side} == -1) ? $other_hit->{query_end} : $hit->{query_end};

		print STDERR Dumper($hit, $other_hit) if ($debug);
		print STDERR "overlap_start = $overlap_start, overlap_end = $overlap_end\n" if ($debug);

		my @base_diffs = match_to_base_diffs( $hit, $mi->{read_seq}, $mg->{ref_seq_matched} );
		
		my @trimmed_base_diffs;
	
		#@base_diffs is in order by the reference sequence
		#which way we want to go depends on which furthest from end

		#this is the right side of the query...
		
		print STDERR "Before adjustment\n" if ($debug);
		print STDERR Dumper($mi) if ($debug);
		#print STDERR Dumper (@base_diffs);
		print STDERR "Traversing list\n" if ($debug);


		my $trimmed = 0;

		#normally these are in order by the reference sequence,
		#we need it to be in order by the query sequence
		@base_diffs = reverse @base_diffs if ($hit->{strand} * $hit->{read_side} == -1);
				
		foreach my $base_diff (@base_diffs)
		{
			print STDERR Dumper($base_diff) if ($debug);
		
			#clear the list if there is a mismatch in the overlap region
			if (!$base_diff->{match} && ($base_diff->{query_position} <= $overlap_end) && ($base_diff->{query_position} >= $overlap_start))
			{
				@trimmed_base_diffs = ();
				$trimmed = 1;
				print STDERR "LIST DEL $base_diff->{query_position}\n" if ($debug);
				print STDERR "INSERTION!\n" if ($base_diff->{insertion} && $debug);
			}
			else 
			{
				push @trimmed_base_diffs, $base_diff;
			}
		}
		
		@trimmed_base_diffs = reverse @trimmed_base_diffs if ($hit->{read_side} == -1);	
		
		$hit->{reference_start} = $trimmed_base_diffs[0]->{reference_position};
		$hit->{reference_end} = $trimmed_base_diffs[-1]->{reference_position};

		$hit->{query_start} = $trimmed_base_diffs[0]->{query_position};
		$hit->{query_end} = $trimmed_base_diffs[-1]->{query_position};
	
		($hit->{reference_start}, $hit->{reference_end}) = ($hit->{reference_end}, $hit->{reference_start})
			if ( $hit->{strand} == -1 );
		
		#### MUST change the sequence
		#### WARNING: Mismatch number and indels not correctly updated at this point!
		if ($trimmed)
		{
			print STDERR "TRIMMED\n" if ($debug);

			add_matched_ref_seq_to_match_groups($mg, $ref_string);
			
			
			print STDERR Dumper($mi) if ($debug);
			print STDERR Dumper(@trimmed_base_diffs) if ($debug);
		}
		
						
				
		print STDERR "After adjustment\n" if ($debug);
		print STDERR Dumper($mi) if ($debug);
	}
	
}


=head2 print_candidate_junctions

 Title   : print_candidate_junctions
 Usage   : print_candidate_junctions( "junction.fna, $ref_seq_string, \@match_list, 50 );
 Function: Creates sequences that reproduce the junctions predicted in the list of hybrid reads.
 Returns : 
 
=cut

sub print_candidate_junctions
{
	my $debug = 0;
	my ($hybrid_read_delta_file_name, $hybrid_read_fastq_file_name, $output_fasta_file_name, $reference_sequence_string_hash_ref, $seq_id, $flanking_length) = @_;

	##output file
	my $candidate_junction_fasta = Bio::SeqIO->new( -file => ">$output_fasta_file_name", -format => "fasta", -verbose => -1);

	##input files
	my $md = MummerDelta->new(-file_name => "$hybrid_read_delta_file_name", -dont_reverse => 1);
	my $hybrid_fastq = FastqLite->new( -file => "<$hybrid_read_fastq_file_name");
	my $read_seq = $hybrid_fastq->next_seq;
	#my $hybrid_fasta = Bio::SeqIO->new( -file => "$hybrid_read_fasta_file_name", -format => "fasta", -verbose => -1);


	### Method
	###
	### Hash junctions by a key showing the inner coordinate of the read.
	### and the direction propagating from that position in the reference sequence.
	### Prefer the unique or lower coordinate side of the read for main hash.
	###
	### -1/+1 are assigned to each match group based on the side of the read. 
			
	my %printed_keys;
	my $i = 0;
	READ: while (my @read_list = $md->get_next_list)
	{

		#move forward until we reach the correct read in the fastq file
		#the query of each item will be the same
		while ($read_seq->{id} ne $read_list[0]->{query})
		{
		#	print STDERR $read_seq->id . " $read->{query}\n";
			$read_seq = $hybrid_fastq->next_seq;
			die "Could not find sequence $read_list[0]->{query}" if (!$read_seq);
			$i++;
			print STDERR "  $i\n"if ($i % 1000 == 0);
		}

		#print Dumper($read);
		my $mi = read_to_match_info(\@read_list, $reference_sequence_string_hash_ref->{$seq_id}, $read_seq);
		$mi->{query} = $read_list[0]->{query} if ($debug); ## only necessary if printing out certain file
		my $mg = $mi->{groups};

		#there should be two match groups
		if (scalar @$mg != 2)
		{
			print Dumper(@$mg);
			die "Expected two match groups\n";
		}
		
		#print Dumper(@mg);
		
		### ignore if both match groups have multiples
		### really want to do this??
		next READ if ( ( scalar @{$mg->[0]->{matches}} != 1) && ( scalar @{$mg->[1]->{matches}} != 1) );
		
		#rules for sorting:
		
		#otherwise, make sure the unique end is first
		($mg->[0], $mg->[1]) = ($mg->[1], $mg->[0]) if (@{$mg->[0]->{matches}} != 1);
		
		#if both are unique, put lowest coords first
		if ( (@{$mg->[0]->{matches}} == 1) && (@{$mg->[1]->{matches}} == 1) )
		{
			($mg->[0], $mg->[1]) = ($mg->[1], $mg->[0]) if ($mg->[0]->{matches}->[0]->{reference_start} < $mg->[1]->{matches}->[0]->{reference_start});
		}
		
		my $unique_hit = $mg->[0]->{matches}->[0];
		
		#re-sort second matches to avoid ones with mismatches
		@{$mg->[1]->{matches}} = sort { ($a->{mismatches} <=> $b->{mismatches}) || ($a->{reference_start} <=> $b->{reference_end})} @{$mg->[1]->{matches}};
		my $second_hit = $mg->[1]->{matches}->[0];
		
		## it is possible for the overlap to contain mismatches or indels!
		## we want to adjust these matches before creating hash keys and constructing candidate junctions!
		$unique_hit->{read_side} = ($unique_hit->{query_start} < $second_hit->{query_start}) ? -1 : +1;	
		$second_hit->{read_side} = -$unique_hit->{read_side};	
		correct_overlapping_mismatches($mi, $reference_sequence_string_hash_ref->{$seq_id});
		
		#create hash key and store information about the location of this 
		my $hash_strand = $unique_hit->{read_side} * $unique_hit->{strand};
		my $hash_coord = ($hash_strand == +1) ? $unique_hit->{reference_start} : $unique_hit->{reference_end};
		$unique_hit->{hash_key} = $hash_coord . "/" . $hash_strand;		
		$unique_hit->{hash_coord} = $hash_coord;
		$unique_hit->{hash_strand} = $hash_strand;

		$hash_strand = $second_hit->{read_side} * $second_hit->{strand};
		$hash_coord = ($hash_strand == +1) ? $second_hit->{reference_start} : $second_hit->{reference_end};
		$second_hit->{hash_key} = $hash_coord . "/" . $hash_strand;	
		$second_hit->{hash_coord} = $hash_coord;	
		$second_hit->{hash_strand} = $hash_strand;	

		# For now this *just* uses the first match group to build the sequence.
		# Ideally, it should look for some sort of consensus in the reads.
			
		#first re-sort by where they match within the read
		my $m_1 = $mi->{groups}->[0]->{matches}->[0];
		my $m_2 = $mi->{groups}->[1]->{matches}->[0];
		
		#how much overlap is there between the two matches?
		#positive if the middle sequence can match either side of the read
		#negative if there is sequence in the read NOT matched on either side 
		my $overlap = $m_1->{query_end} - $m_2->{query_start} + 1;

		## this is the sequence NOT present in the reference genome		
		my $unique_read_seq_string = '';
		$unique_read_seq_string = substr $mi->{read_seq}->{1}, $m_1->{query_end}, -$overlap if ($overlap < 0);
		
		####
		#### Need to add safety measures for junctions near the end of the reference sequence
		#### where these substr will draw a blank.....
		####
		
		print STDERR Dumper($m_1, $m_2) if ($debug);

		my $junction_id = join '_', $m_1->{reference}, $m_1->{hash_key}, $m_2->{reference}, $m_2->{hash_key}, $overlap, $unique_read_seq_string;
		my $alt_junction_id = join '_', $m_2->{reference}, $m_2->{hash_key}, $m_1->{reference}, $m_1->{hash_key}, $overlap, $unique_read_seq_string;

		##if the alt_junction_key already exists, add to it, instread of the preferred one
		if ($printed_keys{$alt_junction_id})
		{
			$junction_id = $alt_junction_id;
		}
		$printed_keys{$junction_id}++;
		
		##print whenever we get two that are the same
		if ($printed_keys{$junction_id} == 2)
		{
			my $genome_seq_string = $reference_sequence_string_hash_ref->{$seq_id};
			my $junction_seq_string = '';

			##first end
			if ($m_1->{hash_strand} * $m_1->{read_side} == 1)
			{
				my $add_seq = substr $genome_seq_string,  $m_1->{hash_coord}-($flanking_length-1)-1, $flanking_length;
				$junction_seq_string .= $add_seq;
				
				print STDERR "Side 1: $m_1->{hash_strand} * $m_1->{read_side} $m_1->{hash_coord}-($flanking_length-1)-1, $flanking_length\n$add_seq\n" if ($debug);
			}
			else # ($m_1->{hash_strand} * $m_1->{read_side} == -1)
			{
				my $add_seq = substr $genome_seq_string,  $m_1->{hash_coord}-1, $flanking_length;
				my $temp_seq = new Bio::Seq(-seq => $add_seq);
				$add_seq = $temp_seq->revcom->seq;
				$junction_seq_string .= $add_seq;
				
				print STDERR "Side 1: $m_1->{hash_strand} * $m_1->{read_side} $m_1->{hash_coord}-1, $flanking_length, $flanking_length\n$add_seq\n" if ($debug);
			}
			
			$junction_seq_string .= $unique_read_seq_string;
			
			## this only applies if the overlap is positive (sequence is shared between the two ends)
			my $overlap_offset = 0;
			$overlap_offset = $overlap if ($overlap > 0);
			
			##second end
			if ($m_2->{hash_strand} * $m_2->{read_side} == 1)
			{
				my $add_seq = substr $genome_seq_string,  $m_2->{hash_coord}+$overlap_offset-1, $flanking_length-$overlap_offset;
				$junction_seq_string .= $add_seq;
				
				print STDERR "Side 2: $m_2->{hash_strand} * $m_1->{read_side}  $m_2->{hash_coord}+$overlap_offset, $flanking_length-$overlap_offset\n$add_seq\n" if ($debug);
			}
			else # ($m_2->{hash_strand} * $m_2->{read_side} == -1)
			{
				my $add_seq = substr $genome_seq_string,  $m_2->{hash_coord}-($flanking_length-1)-1, $flanking_length-$overlap_offset;
				my $temp_seq = new Bio::Seq(-seq => $add_seq);
				$add_seq = $temp_seq->revcom->seq;
				$junction_seq_string .= $add_seq;
							
				print STDERR "Side 2: $m_2->{hash_strand} * $m_1->{read_side} $m_2->{hash_coord}-($flanking_length-$overlap_offset-1), $flanking_length-$overlap_offset\n$add_seq\n" if ($debug);
			}
		
			#write the sequence, adding the tag to the beginning of the name here
			my $junction_seq = new Bio::Seq(-display_id => "$new_junction_sequence_tag\_$junction_id", -seq => "$junction_seq_string");
			$candidate_junction_fasta->write_seq($junction_seq);
		}
	}
}


return 1;

